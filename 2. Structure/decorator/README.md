# 裝飾者/裝飾器  Wrapper/Decorator
允許你通過將對象放入包含行為的特殊封裝對像中來為原對象綁定新的行為

## 優缺點
### 優點
1. 無需創建新子類即可擴展對象的行為

2. 可以在運行時添加或刪除對象的功能

3. 可以用多個裝飾封裝對象來組合幾種行為

4. Single Responsibility Principle

    你可以將實現了許多不同行為的一個大類拆分為多個較小的類


### 缺點
* 在封裝器棧中刪除特定封裝器比較困難
* 實現行為不受裝飾棧順序影響的裝飾比較困難
* 各層的初始化配置代碼看上去可能會很糟糕

## Architecture

![](https://refactoringguru.cn/images/patterns/diagrams/decorator/structure.png?id=8c95d894aecce5315cc1)

1. 部件(Component)

    * 聲明封裝器和被封裝對象的公用接口

2. 具體部件(Concrete Component)
    
    * 是被封裝對象所屬的類
    * 定義了基礎行為，但裝飾類可以改變這些行為

3. 基礎裝飾(Base Decorator)
    
    * 有一個指向被封裝對象的引用成員變量
    * 該變量的類型應當被聲明為通用部件接口，這樣它就可以引用具體的部件和裝飾
    * 會將所有操作委派給被封裝的對象
    
4. 具體裝飾類(Concrete Decorators)

    * 定義了可動態添加到部件的額外行為
    * 具體裝飾類會重寫裝飾基類的方法，並在調用父類方法之前或之後進行額外的行為

5. 客戶端(Client)
    
    * 可以使用多層裝飾來封裝部件，只要它能使用通用接口與所有對象互動即可
    
## 應用場景
* 如果你希望在無需修改代碼的情況下即可使用對象，且希望在運行時為對像新增額外的行為
* 如果用繼承來擴展對象行為的方案難以實現或者根本不可行

## 實現方式
下列七個步驟
1. 確保業務邏輯可用一個基本組件及多個額外可選層次表示

2. 找出基本組件和可選層次的通用方法

    * 創建一個組件接口並在其中聲明這些方法
    
3. 創建一個具體組件類，並定義其基礎行為
    
    
4. 創建裝飾基類， 使用一個成員變量存儲指向被封裝對象的引用

    * 該成員變量必須被聲明為組件接口類型，從而能在運行時連接具體組件和裝飾
    * 裝飾基類必須將所有工作委派給被封裝的對象
    
5. 確保所有類實現組件接口

6. 將裝飾基類擴展為具體裝飾
    
    * 具體裝飾必須在調用父類方法(總是委派給被封裝對象)之前或之後執行自身的行為

7. 客戶端代碼負責創建裝飾並將其組合成客戶端所需的形式