# 適配器/封裝器 Adapter/Wrapper
它能使接口不兼容的對象能夠相互合作

## 優缺點
### 優點
1. Single Responsibility Principle

    可以將接口或數據轉換代碼從程序主要業務邏輯中分離

2. Open/Closed Principle

    只要客戶端代碼通過客戶端接口與適配器進行交互， 你就能在不修改現有客戶端代碼的情況下在程序中添加新類型的適配器
    


### 缺點
* 代碼整體複雜度增加， 因為你需要新增一系列接口和類
* 有時直接更改服務類使其與其他代碼兼容會更簡單

## Architecture
### 對象適配器
使用了構成原則:
* 實現了其中一個對象的接口， 並對另一個對象進行封裝
* 所有流行的編程語言都可以實現

![對象](https://refactoringguru.cn/images/patterns/diagrams/adapter/structure-object-adapter.png?id=33dffbe3aece29416244)

1. 客戶端(Client)

    * 包含當前程序業務邏輯的類

2. 客戶端接口(Client Interface)
    
    * 描述了其他類與客戶端代碼合作時必須遵循的協議
   
3. 服務(Service)
    
    * 其中有一些功能類（通常來自第三方或遺留系統)
    * 客戶端與其接口不兼容，因此無法直接調用其功能
    
4. 適配器(Adapter)

    * 一個可以同時與客戶端和服務交互的類
        
        * 在實現客戶端接口的同時封裝了服務對象
    * 接受客戶端通過適配器接口發起的調用，並將其轉換為適用於被封裝服務對象的調用

5. 好處
    * 客戶端代碼只需通過接口與適配器交互即可， 無需與具體的適配器類耦合
    * 可以向程序中添加新類型的適配器而無需修改已有代碼
    * 在服務類的接口被更改或替換時很有用： 你無需修改客戶端代碼就可以創建新的適配器類

### 類適配器
使用了繼承機制:
* 同時繼承兩個對象的接口
* 請注意， 這種方式僅能在支持多重繼承的編程語言中實現， 例如C++

![類](https://refactoringguru.cn/images/patterns/diagrams/adapter/structure-class-adapter.png?id=e1c60240508146ed3b98)

* 類適配器
    * 不需要封裝任何對象， 因為它同時繼承了客戶端和服務的行為
    * 適配功能在重寫的方法中完成
    * 最後生成的適配器可替代已有的客戶端類進行使用


## 應用場景
* 當你希望使用某個類， 但是其接口與其他代碼不兼容時
* 如果您需要復用這樣一些類， 他們處於同一個繼承體系， 並且他們又有了額外的一些共同的方法， 但是這些共同的方法不是所有在這一繼承體系中的子類所具有的共性

## 實現方式
下列六個步驟
1. 確保至少有兩個類的接口不兼容

    * 一個無法修改（通常是第三方、遺留系統或者存在眾多已有依賴的類）的功能性服務類
    * 一個或多個將受益於使用服務類的客戶端類
    
2. 聲明客戶端接口， 描述客戶端如何與服務交互
    
3. 創建遵循客戶端接口的適配器類
    
    * 所有方法暫時都為空
    
4. 在適配器類中添加一個成員變量用於保存對於服務對象的引用

    * 通常情況下會通過構造函數對該成員變量進行初始化， 但有時在調用其方法時將該變量傳遞給適配器會更方便
    
5. 依次實現適配器類客戶端接口的所有方法

    * 適配器會將實際工作委派給服務對象， 自身只負責接口或數據格式的轉換

6. 客戶端必須通過客戶端接口使用適配器

    * 這樣一來， 你就可以在不影響客戶端代碼的情況下修改或擴展適配器
