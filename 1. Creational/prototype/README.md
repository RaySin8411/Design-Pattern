# 原型/克隆 Prototype/Clone
使你能夠複製已有對象， 而又無需使代碼依賴它們所屬的類

## 優缺點
### 優點
1. 可以克隆對象， 而無需與它們所屬的具體類相耦合

2. 可以克隆預生成原型， 避免反復運行初始化代碼
    
3. 可以更方便地生成複雜對象

4. 可以用繼承以外的方式來處理複雜對象的不同配置

### 缺點
克隆包含循環引用的複雜對象可能會非常麻煩

## Architecture
### 基本
![基本](https://refactoringguru.cn/images/patterns/diagrams/prototype/structure.png?id=088102c5e9785ff45deb)

1. 原型(Prototype)

    * 接口將對克隆方法進行聲明
    * 在絕大多數情況下，其中只會有一個名為 clone克隆的方法

2. 具體原型(Concrete Prototype)
    
    * 類將實現克隆方法
    * 除了將原始對象的數據複製到克隆體中之外，該方法有時還需處理克隆過程中的極端情況
        * 例如
            * 克隆關聯對象
            * 梳理遞歸依賴
            * 等等
   
3. 客戶端(Client)
    
    * 可以復制實現了原型接口的任何對象

### 原型註冊表
![](https://refactoringguru.cn/images/patterns/diagrams/prototype/structure-prototype-cache.png?id=609c2af5d14ed55dcbb2)

* 原型註冊表(Prototype Registry)
    * 提供了一種訪問常用原型的簡單方法，其中存儲了一系列可供隨時復制的預生成對象
    * 最簡單的註冊表原型是一個的哈希表
    * 但如果需要使用名稱以外的條件進行搜索，你可以創建更加完善的註冊表版本
        * 名称 → 原型


## 應用場景
* 如果你需要復制一些對象， 同時又希望代碼獨立於這些對象所屬的具體類
* 如果子類的區別僅在於其對象的初始化方式， 那麼你可以使用該模式來減少子類的數量

## 實現方式
下列四個步驟
1. 創建原型接口， 並在其中聲明方法
    
2. 原型類必須另行定義一個以該類對象為參數的構造函數
    
3. 克隆方法通常只有一行代碼

    使用運算符調用原型版本的構造函數
    
4. 創建一個中心化原型註冊表， 用於存儲常用原型
